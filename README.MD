# Distributed Rate Limiter

> **Goal**: A productionâ€‘grade, distributed rate limiting system that demonstrates deep understanding of **concurrency, distributed systems, and realâ€‘world tradeâ€‘offs**.

---

## 1. Problem Definition (What We Are Solving)

We want to **control how many requests** a client can make to a system over time **across multiple servers**.

### Functional Requirements

* Limit requests by:
    * IP
    * User ID
    * Organization
* Support multiple algorithms:
    * Token Bucket
    * Sliding Window Log (optimized) ðŸ‘‰ *Future Scope*
    * Sliding Window Counter (optimized) (optimized) ðŸ‘‰ *Future Scope*
* Distributed correctness (multiple app instances) (multiple app instances)
* Low latency (< 5ms overhead)

### Nonâ€‘Functional Requirements

* Highly concurrent
* Fault-tolerant
* Horizontally scalable
* Deterministic behavior under load

---

## 2. Highâ€‘Level Architecture

```
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚   Client     â”‚
                â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
                â”‚ API Gateway  â”‚
                â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Rate Limiter Service (Java) â”‚
        â”‚  - Algorithm Engine         â”‚
        â”‚  - Policy Resolver          â”‚
        â”‚  - Concurrency Control      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
                â”‚    Redis     â”‚
                â”‚ (Atomic Ops) â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Idea**: All state lives in Redis â†’ app servers are stateless.

---

## 3. Core Concepts & Data Modeling

### 3.1 Identity Keys

Each request maps to a **rateâ€‘limit key**:

```
rate_limit:{scope}:{identifier}

Examples:
rate_limit:ip:192.168.1.1
rate_limit:user:12345
rate_limit:org:acme_corp
```

---

## 4. Algorithms (DSAâ€‘Heavy Core)

### 4.1 Token Bucket (Primary Algorithm)

**Idea**: Tokens refill at a fixed rate. Each request consumes 1 token.

#### Data Stored in Redis

```
{
  tokens: float,
  last_refill_timestamp: long
}
```

#### Steps (Per Request)

1. Fetch current bucket
2. Refill tokens based on elapsed time
3. If tokens >= 1 â†’ allow
4. Else â†’ reject
5. Persist updated state atomically

#### DSA Used

* Hash Maps
* Floatingâ€‘point math
* Timeâ€‘based computation

---

### 4.2 Sliding Window Log (Accurate, Expensive) ðŸ‘‰ *Future Scope*

Store **timestamps of requests**.

```
Redis Sorted Set:
key = rate_limit:user:123
value = timestamp
```

Steps:

1. Remove timestamps < window_start
2. Count remaining entries
3. Allow / reject

DSA:

* Queue / Deque
* Sorted Set

---

### 4.3 Sliding Window Counter (Optimized) ðŸ‘‰ *Future Scope*

Split time into fixed buckets.

```
current_window_count * weight + previous_window_count * (1 - weight)
```

DSA:

* Hash maps
* Time buckets

---

## 5. Redis Atomicity (CRITICAL)

### Why Atomic Operations Matter

Without atomicity:

* Race conditions
* Overâ€‘allowing requests

### Solution

Use **Lua scripts** in Redis:

* Read state
* Compute new state
* Write back

All in **one atomic operation**.

---

## 6. Java Service Internal Architecture

```
RateLimiterService
 â”œâ”€â”€ RateLimiterEngine
 â”‚     â”œâ”€â”€ TokenBucketLimiter
 â”‚     â”œâ”€â”€ RedisBucketLimiter
 â”‚     â”œâ”€â”€ SlidingWindowLimiter ðŸ‘‰ *Future Scope*
 â”‚
 â”œâ”€â”€ PolicyResolver
 â”‚     â”œâ”€â”€ UserPolicy
 â”‚     â”œâ”€â”€ OrgPolicy
 â”‚     â”œâ”€â”€ IpPolicy
 â”‚
 â”œâ”€â”€ MetricsCollector
```

---

## 7. Concurrency Handling (Inâ€‘Process)

### Problem

Multiple threads can hit the limiter simultaneously.

### Strategy

* Redis handles crossâ€‘node consistency
* Java handles:

    * Thread pools
    * Time calculations

Use:

* `ExecutorService`
* `CompletableFuture`

---

## 8. Request Flow (Stepâ€‘byâ€‘Step)

```
Client Request
   â†“
Extract identity (IP / User / Org)
   â†“
Resolve policy (limits, algorithm)
   â†“
Execute Redis Lua script
   â†“
Allowed ? Forward : Reject (429)
```

---

## 9. Hierarchical Rate Limiting (Advanced)

Request must pass **ALL levels**:

```
IP â†’ User â†’ Organization
```

Algorithm:

1. Check org bucket
2. Check user bucket
3. Check IP bucket

Fail fast on first violation.

---

## 10. Hot Key Mitigation

### Problem

One key gets massive traffic.

### Solutions

* Local inâ€‘memory preâ€‘check
* Key sharding
* Request coalescing

---

## 11. Dynamic Configuration

### Requirement

Change limits without redeploying.

### Design

* Config stored in DB / Redis
* Cached locally
* Periodic refresh

---

## 12. Failure Scenarios & Tradeâ€‘offs

### Redis Down

Options:

* Fail open (allow traffic) ðŸ‘‰ *Configurable â€“ Future Enhancement*
* Fail closed (block traffic)

---

## 13. Metrics & Observability

Track:

* Allowed vs blocked requests
* Redis latency
* Key cardinality

Expose `/metrics` endpoint.

---

## 14. Testing Strategy

### Unit Tests

* Token refill logic
* Individual policy tests (user, IP, org)

### Concurrency Tests

* Multiâ€‘threaded request simulation
* Hierarchical policy tests (combined user + IP + org

### Load Tests

* Burst traffic
* API-level integration tests (simulating HTTP requests to /api/request)

---

## 15. Build Roadmap

### Phase 1 â€“ Core Engine

* Implement Token Bucket in Java
* Unit test thoroughly

### Phase 2 â€“ Redis Integration

* Lua scripts
* Atomic guarantees

### Phase 3 â€“ API Layer

* REST endpoint
* Request interceptors

### Phase 4 â€“ Distributed Concerns

* Multiâ€‘instance testing

### Phase 5 â€“ Advanced Features

* Hierarchy
* Dynamic config
* Metrics

---
